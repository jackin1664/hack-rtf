{"version":3,"sources":["webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/bignumber/lib.esm/_version.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/_version.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/fragments.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/address/lib.esm/_version.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/address/lib.esm/index.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/address.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/array.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/null.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/constants/lib.esm/index.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/number.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/strings/lib.esm/_version.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/strings/lib.esm/utf8.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/strings/lib.esm/idna.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/string.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/abi-coder.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/hash/lib.esm/index.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/hash/lib.esm/_version.js","webpack:///./node_modules/web3-eth-abi/node_modules/@ethersproject/abi/lib.esm/interface.js","webpack:///./node_modules/web3-eth-abi/src/index.js"],"names":["logger","_constructorGuard","constructorGuard","hex","checkNew","throwError","errors","UNSUPPORTED_OPERATION","operation","this","_hex","_isBigNumber","Object","freeze","value","toBigNumber","toBN","fromTwos","toTwos","from","substring","other","add","sub","isZero","throwFault","div","mul","isNeg","umod","pow","isNegative","and","or","xor","maskn","shln","shrn","eq","lt","lte","gt","gte","toNumber","error","toString","arguments","length","UNEXPECTED_ARGUMENT","key","type","toHexString","match","toHex","throwArgumentError","String","anyValue","fault","params","NUMERIC_FAULT","zeros","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","name","indexOf","populate","object","FormatTypes","sighash","minimal","full","json","paramTypeArray","RegExp","arrayLength","parseInt","arrayChildren","fromObject","components","baseType","_isParamType","format","result","undefined","indexed","map","comp","JSON","parse","stringify","join","allowIndexed","fromString","isParamType","verifyType","node","ParamTypify","param","originalParam","i","newNode","parent","state","allowType","replace","c","allowParams","child","allowName","allowArray","sibling","push","readArray","parseParamType","parseParams","allowIndex","trim","accum","depth","offset","splitNesting","_isFragment","isFragment","EventFragment","split","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","console","log","verifyState","payble","isConstructorFragment","parens","ouputs","outputs","output","isFunctionFragment","returns","regexIdentifier","checkResultErrors","checkErrors","path","Array","isArray","childPath","slice","Coder","localName","dynamic","message","wordSize","_data","_padding","Uint8Array","data","bytes","_writeData","BUFFER_OVERRUN","_getValue","writeValue","set","coerceFunc","_offset","_coerceFunc","coerce","alignedLength","Math","ceil","_peekBytes","readBytes","getChecksumAddress","address","chars","toLowerCase","expanded","charCodeAt","hashed","toUpperCase","ibanLookup","fromCharCode","safeDigits","floor","x","log10","LN10","ibanChecksum","block","checksum","getAddress","super","writer","_throwError","reader","readValue","coder","encode","decode","pack","coders","values","arrayValues","staticWriter","dynamicWriter","updateFuncs","index","dynamicOffset","updateFunc","writeUpdatableValue","baseOffset","func","writeBytes","unpack","baseReader","subReader","dynamicLength","offsetReader","code","consumed","Error","defineProperty","get","count","checkArgumentCount","size","One","MaxUint256","signed","v","maxUintValue","mask","bounds","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","reason","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","Utf8ErrorFuncs","ignore","OVERLONG","getUtf8CodePoints","onError","extraLength","overlongMask","res","j","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","toUtf8Bytes","str","form","current","checkNormalize","normalize","c2","pair","_toUtf8String","codePoints","codePoint","toUtf8String","createTable","lo","createRangeTable","hi","l","h","types","paramTypeBytes","paramTypeNumber","_getCoder","component","_getWordSize","INVALID_ARGUMENT","_getWriter","_getReader","defaultAbiCoder","id","text","_isIndexed","wrapAccessError","property","wrap","checkNames","fragment","reduce","fragments","abi","filter","bucket","deploy","functions","events","signature","functionFragment","eventFragment","nameOrSignatureOrSighash","getSighash","matching","keys","f","nameOrSignatureOrTopic","topichash","getEventTopic","getFunction","constructor","getEvent","_abiCoder","_encodeParams","_decodeParams","errorSignature","CALL_EXCEPTION","method","errorArgs","argument","topics","encodeTopic","pop","dataTypes","dataValues","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","hash","tx","args","topic","decodeEventLog","_isInterface","Buffer","_","utils","EthersAbiCoder","AbiCoder","ParamType","ethersAbiCoder","isObject","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","encodeEventSignature","encodeParameter","encodeParameters","self","mapTypes","formatParam","includes","modifyParams","p","mappedTypes","isSimplifiedStructFormat","structName","assign","mapStructNameAndType","mapStructToCoderFormat","struct","paramTypeBytesArray","paramTypeNumberArray","isBN","isBigNumber","leftPad","isBuffer","maxSize","rightPad","encodeFunctionCall","jsonInterface","decodeParameter","decodeParameters","returnValue","__length__","decodedValue","decodeLog","_this","notIndexedInputs","indexedParams","topicCount","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"mappings":"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","file":"js/chunk.web3-eth-abi.4d517fe7.js","sourcesContent":["export const version = \"bignumber/5.0.6\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardles.\n *\n */\nimport { BN } from \"bn.js\";\nimport { hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nexport function isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\nexport class BigNumber {\n    constructor(constructorGuard, hex) {\n        logger.checkNew(new.target, BigNumber);\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division by zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot modulo negative values\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"cannot raise to negative values\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'and' negative values\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'or' negative values\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"cannot 'xor' negative values\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot mask negative values\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"cannot shift negative values\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check\n        if (arguments.length !== 0) {\n            logger.throwError(\"bigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes piority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have mulitple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n//# sourceMappingURL=bignumber.js.map","\"use strict\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    value = whole + \".\" + fraction;\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexport function parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.,]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    if (multiplier.length - 1 === 0) {\n        return BigNumber.from(value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Prevent underflow\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexport class FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else if (value != null) {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nexport class FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        logger.checkNew(new.target, FixedNumber);\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        // If we are already in range, we're done\n        let comps = this.toString().split(\".\");\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        // Bump the value up by the 0.00...0005\n        const bump = \"0.\" + zeros.substring(0, decimals) + \"5\";\n        comps = this.addUnsafe(FixedNumber.fromString(bump, this.format))._value.split(\".\");\n        // Now it is safe to truncate\n        return FixedNumber.fromString(comps[0] + \".\" + comps[1].substring(0, decimals));\n    }\n    isZero() {\n        return (this._value === \"0.0\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\n//# sourceMappingURL=fixednumber.js.map","export const version = \"abi/5.0.0-beta.153\";\n","\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nexport const FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readble with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, addres bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nexport class EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nexport class ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payble: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nexport class FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payble: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                ouputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class ErrorFragment extends Fragment {\n//}\n//export class StructFragment extends Fragment {\n//}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\nconst regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n","\"use strict\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = arrayify([]);\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() { return hexlify(this._data); }\n    get length() { return this._data.length; }\n    _writeData(data) {\n        this._data = concat([this._data, data]);\n        return data.length;\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        if (bytes.length % this.wordSize) {\n            bytes = concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        let offset = this.length;\n        this.writeValue(0);\n        return (value) => {\n            this._data.set(this._getValue(value), offset);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this._data.length,\n                offset: this._offset + alignedLength\n            });\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc);\n    }\n    readBytes(length) {\n        let bytes = this._peekBytes(0, length);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","export const version = \"address/5.0.3\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\n// We use this for base 36 maths\nimport { BN } from \"bn.js\";\nimport { arrayify, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction getChecksumAddress(address) {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = arrayify(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nexport function getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (new BN(address.substring(4), 36)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nexport function isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexport function getIcapAddress(address) {\n    let base36 = (new BN(getAddress(address).substring(2), 16)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));\n}\nexport function getCreate2Address(from, salt, initCodeHash) {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\nexport class AddressCoder extends Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    encode(writer, value) {\n        try {\n            getAddress(value);\n        }\n        catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    constructor(coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nimport { Coder, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\nexport function pack(writer, coders, values) {\n    if (Array.isArray(values)) {\n        // do nothing\n    }\n    else if (values && typeof (values) === \"object\") {\n        let arrayValues = [];\n        coders.forEach(function (coder) {\n            arrayValues.push(values[coder.localName]);\n        });\n        values = arrayValues;\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== values.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = values[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.writeBytes(staticWriter.data);\n    length += writer.writeBytes(dynamicWriter.data);\n    return length;\n}\nexport function unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    // The amount of dynamic data read; to consume later to synchronize\n    let dynamicLength = 0;\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n            dynamicLength += offsetReader.consumed;\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // @TODO: get rid of this an see if it still works?\n    // Consume the dynamic components in the main reader\n    reader.readBytes(dynamicLength);\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index) => {\n        let name = coder.localName;\n        if (!name) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                get: () => { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                get: () => { throw value; }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nexport class ArrayCoder extends Coder {\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(count, value.length, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nexport class BooleanCoder extends Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n","\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\nexport class DynamicBytesCoder extends Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    encode(writer, value) {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber());\n    }\n}\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n","\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    encode(writer, value) {\n        let data = arrayify(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nexport class NullCoder extends Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n// NFKC (composed)             // (decomposed)\nconst EtherSymbol = \"\\u039e\"; // \"\\uD835\\uDF63\";\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst Two = BigNumber.from(2);\nconst WeiPerEther = BigNumber.from(\"1000000000000000000\");\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nexport { AddressZero, HashZero, EtherSymbol, NegativeOne, Zero, One, Two, WeiPerEther, MaxUint256 };\n//# sourceMappingURL=index.js.map","\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\nimport { Coder } from \"./abstract-coder\";\nexport class NumberCoder extends Coder {\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    encode(writer, value) {\n        let v = BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        }\n        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n}\n","export const version = \"strings/5.0.3\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nexport var UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nexport var Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong reperesentation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nexport const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = arrayify(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid contimuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return arrayify(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nexport function _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nexport function _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nexport function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexport function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map","\"use strict\";\nimport { toUtf8CodePoints, _toUtf8String, UnicodeNormalizationForm } from \"./utf8\";\nfunction bytes2(data) {\n    if ((data.length % 4) !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function (value) { return [parseInt(value, 16)]; };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        }\n        else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\nfunction matchMap(value, ranges) {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) {\n                continue;\n            }\n            return range;\n        }\n    }\n    return null;\n}\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\nconst Table_B_2_ranges = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [23], l: 127 },\n    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n    { h: 26, s: 32, e: [17], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [17], l: 56 },\n    { h: 24, s: -119601, e: [17], l: 58 },\n    { h: 24, s: -119659, e: [17], l: 58 },\n    { h: 24, s: -119717, e: [17], l: 58 },\n    { h: 24, s: -119775, e: [17], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nfunction flatten(values) {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, []);\n}\nexport function _nameprepTableA1(codepoint) {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\nexport function _nameprepTableB2(codepoint) {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) {\n        return [codepoint + range.s];\n    }\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) {\n        return codes;\n    }\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) {\n        return [codepoint + shift[0]];\n    }\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) {\n        return complex;\n    }\n    return null;\n}\nexport function _nameprepTableC(codepoint) {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\nexport function nameprep(value) {\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n        return value.toLowerCase();\n    }\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) {\n            return [];\n        }\n        if (code >= 0xfe00 && code <= 0xfe0f) {\n            return [];\n        }\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) {\n            return codesTableB2;\n        }\n        // No Substitution\n        return [code];\n    }));\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n    // IDNA extras\n    let name = _toUtf8String(codes);\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n    // IDNA: 4.2.4\n    if (name.length > 63) {\n        throw new Error(\"too long\");\n    }\n    return name;\n}\n//# sourceMappingURL=idna.js.map","\"use strict\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { DynamicBytesCoder } from \"./bytes\";\nexport class StringCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    encode(writer, value) {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n    decode(reader) {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    encode(writer, value) {\n        return pack(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n","\"use strict\";\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n    constructor(coerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data) {\n        return new Reader(data, this._getWordSize(), this.coerceFunc);\n    }\n    _getWriter() {\n        return new Writer(this._getWordSize());\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data)));\n    }\n}\nexport const defaultAbiCoder = new AbiCoder();\n","\"use strict\";\nimport { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nconst Zeros = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nexport function isValidName(name) {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\");\n            }\n        }\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid address - \" + String(name), \"name\", name);\n    }\n    let result = Zeros;\n    while (name.length) {\n        const partition = name.match(Partition);\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n        name = partition[2] || \"\";\n    }\n    return hexlify(result);\n}\nexport function id(text) {\n    return keccak256(toUtf8Bytes(text));\n}\nexport const messagePrefix = \"\\x19Ethereum Signed Message:\\n\";\nexport function hashMessage(message) {\n    if (typeof (message) === \"string\") {\n        message = toUtf8Bytes(message);\n    }\n    return keccak256(concat([\n        toUtf8Bytes(messagePrefix),\n        toUtf8Bytes(String(message.length)),\n        message\n    ]));\n}\n//# sourceMappingURL=index.js.map","export const version = \"hash/5.0.3\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\nimport { defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, ParamType } from \"./fragments\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport { checkResultErrors };\nexport class LogDescription extends Description {\n}\nexport class TransactionDescription extends Description {\n}\nexport class Indexed extends Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\nfunction checkNames(fragment, type, params) {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${type} parameter ${JSON.stringify(param.name)} in ${fragment.format(\"full\")}`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, {});\n}\nexport class Interface {\n    constructor(fragments) {\n        logger.checkNew(new.target, Interface);\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n        defineReadOnly(this, \"_abiCoder\", getStatic((new.target), \"getAbiCoder\")());\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"errors\", {});\n        defineReadOnly(this, \"events\", {});\n        defineReadOnly(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    checkNames(fragment, \"input\", fragment.inputs);\n                    checkNames(fragment, \"output\", fragment.outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = FormatTypes.full;\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return getAddress(address);\n    }\n    static getSighash(functionFragment) {\n        return hexDataSlice(id(functionFragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return id(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normlize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normlize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(functionFragment) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return getStatic(this.constructor, \"getSighash\")(functionFragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return getStatic(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = arrayify(data);\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", hexlify(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = arrayify(data);\n        let reason = null;\n        let errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4:\n                if (hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n                    errorSignature = \"Error(string)\";\n                    reason = this._abiCoder.decode([\"string\"], bytes.slice(4))[0];\n                }\n                break;\n        }\n        return logger.throwError(\"call revert exception\", Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            errorSignature: errorSignature,\n            errorArgs: [reason],\n            reason: reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return id(value);\n            }\n            else if (param.type === \"bytes\") {\n                return keccak256(hexlify(value));\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\"address\"], [value]);\n            }\n            return hexZeroPad(hexlify(value), 32);\n        };\n        values.forEach((value, index) => {\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TOOD\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }\n                    });\n                }\n                else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    get: () => { throw wrapAccessError(`index ${i}`, value); }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe jsut a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n}\n","/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\n\nvar Buffer = require('buffer').Buffer;\nvar _ = require('underscore');\nvar utils = require('web3-utils');\n\nvar EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\nvar ParamType = require('@ethersproject/abi').ParamType;\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n\n// result method\nfunction Result() {\n}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName).slice(0, 10);\n};\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n\n    return utils.sha3(functionName);\n};\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types)\n\n    params = params.map(function (param, index) {\n        let type = types[index]\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type\n        }\n\n        param = self.formatParam(type, param)\n\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    return param.map(p =>\n                        modifyParams(\n                            ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))),\n                            p\n                        )\n                    )\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i])\n                    } else {\n                        param[i] = self.formatParam(c.name, param[i])\n                    }\n                })\n            }\n            modifyParams(coder, param)\n        }\n\n        return param;\n    })\n\n    return ethersAbiCoder.encode(types, params);\n};\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function'){\n            type.type = \"bytes24\"\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(\n                Object.assign(\n                    self.mapStructNameAndType(structName),\n                    {\n                        components: self.mapStructToCoderFormat(type[structName])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        mappedTypes.push(type);\n    });\n\n    return mappedTypes;\n};\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n\n    return {type: type, name: structName};\n};\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(\n                Object.assign(\n                    self.mapStructNameAndType(key),\n                    {\n                        components: self.mapStructToCoderFormat(struct[key])\n                    }\n                )\n            );\n\n            return;\n        }\n\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n\n    return components;\n};\n\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p))\n    }\n\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size);\n        }\n    }\n\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2)\n            }\n        }\n\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2)\n        }\n    }\n\n    return param\n};\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error(\n            'Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.'\n        );\n    }\n\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''));\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        decodedValue = (decodedValue === '0x') ? null : decodedValue;\n\n        returnValue[i] = decodedValue;\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = _.isArray(topics) ? topics : [topics];\n\n    data = data || '';\n\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n\n    // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        } else {\n            notIndexedInputs[i] = input;\n        }\n    });\n\n\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParameters(notIndexedInputs, nonIndexedData) : [];\n\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n\n\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n\n        returnValue.__length__++;\n    });\n\n    return returnValue;\n};\n\nvar coder = new ABICoder();\n\nmodule.exports = coder;\n"],"sourceRoot":""}